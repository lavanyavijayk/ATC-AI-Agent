"""
ATC Agent Module
================
This module implements an AI-powered Air Traffic Controller agent using LangGraph
for workflow management and Google's Gemini LLM for decision-making.

The agent handles:
- Landing operations: Guiding aircraft through the landing pattern
- Takeoff operations: Clearing aircraft for departure
- Safety checks: Validating commands against traffic conflicts
"""

import os
import json
import re
import time
from typing import TypedDict, Literal

import requests
import google.generativeai as genai
from langgraph.graph import StateGraph, END

from utils.weather_data import WeatherInfo
from flight import Airport, Runway, Flight
from database.atc_db import ATCDatabase

# ============================================================================
# Configuration
# ============================================================================

# Configure Google Gemini API key from environment variable
API_KEY = os.getenv("GOOGLE_API_KEY", "AIzaSyBR1WOX31bjxbex2Wy0dBx_PnKMpgRguLQ")
genai.configure(api_key=API_KEY)

# API Base URL for the ATC Simulator
API_BASE_URL = "http://localhost:8000/api"


# ============================================================================
# LLM Wrapper Class
# ============================================================================

class LLM:
    """
    Wrapper class for Google's Gemini Language Model.
    
    Provides a simple interface to invoke the Gemini model with
    configured generation parameters for ATC decision-making.
    """
    
    def __init__(self):
        """Initialize the LLM wrapper."""
        self.model_name = 'gemini-2.5-flash'
        print(f"[LLM] Initialized with model: {self.model_name}")

    def invoke(self, prompt: str) -> str:
        """
        Send a prompt to the Gemini model and get a response.
        
        Args:
            prompt: The text prompt to send to the model
            
        Returns:
            The model's response text, or None if an error occurred
        """
        try:
            print("[LLM] Invoking Gemini model...")
            model = genai.GenerativeModel(self.model_name)
            
            response = model.generate_content(
                prompt,
                generation_config=genai.types.GenerationConfig(
                    temperature=0.1,  # Low temperature for consistent, deterministic outputs
                    top_p=0.95,
                )
            )
            
            response_preview = response.text[:200] if len(response.text) > 200 else response.text
            print(f"[LLM] Response received: {response_preview}...")
            return response.text
            
        except Exception as e:
            print(f"[LLM] ERROR: {e}")
            return None


# ============================================================================
# State Definition
# ============================================================================

class ATCState(TypedDict):
    """
    TypedDict defining the state structure for the ATC workflow.
    
    Attributes:
        messages: List of conversation messages between system and LLM
        command: The current command generated by the LLM
        result: The result after safety validation
        flight_id: The unique identifier for the flight
        flight_info: Dictionary containing all flight information
        retry_count: Number of retry attempts for failed safety checks
        prev_convo: Previous conversation history from database
    """
    messages: list
    command: dict
    result: dict
    flight_id: str
    flight_info: dict
    retry_count: int
    prev_convo: list


# ============================================================================
# ATC Agent Class
# ============================================================================

class ATCAgent:
    """
    AI-powered Air Traffic Controller Agent.
    
    Uses LangGraph for workflow management and Gemini LLM for intelligent
    decision-making. Handles both landing and takeoff operations with
    built-in safety checks.
    
    Workflow:
        entry_point -> [landing_node | takeoff_node] -> safety_check -> [retry | end]
    """
    
    def __init__(self, airport: Airport, flight_id: str, flight_info: dict):
        """
        Initialize the ATC Agent for a specific flight.
        
        Args:
            airport: The Airport object containing runway information
            flight_id: The callsign/identifier of the flight to manage
            flight_info: Dictionary containing current flight data
        """
        print(f"[INIT] Creating ATCAgent for flight {flight_id}")
        
        # Store references
        self.airport = airport
        self.flight_id = flight_id
        self.flight_info = flight_info
        
        # Initialize LLM
        self.llm = LLM()
        
        # Create Flight object for runway assignment
        self.flight_obj = Flight(
            flight_id,
            flight_info['aircraft_type'],
            flight_info['origin'],
            flight_info['destination']
        )
        
        # Initialize workflow
        print(f"[INIT] Building LangGraph workflow...")
        self.workflow = self._build_workflow()
        
        # Initialize state
        self.state = {
            "messages": [],
            "command": {},
            "result": {},
            "flight_id": flight_id,
            "flight_info": flight_info,
            "retry_count": 0,
            "prev_convo": []
        }
        
        print(f"[INIT] ATCAgent initialized successfully for {flight_id}")
    
    def _build_workflow(self) -> StateGraph:
        """
        Build and compile the LangGraph workflow.
        
        Returns:
            Compiled StateGraph workflow
        """
        workflow = StateGraph(ATCState)
        
        # Add workflow nodes
        workflow.add_node("entry_point", self.entry_point)
        workflow.add_node("landing_node", self.landing_node)
        workflow.add_node("takeoff_node", self.takeoff_node)
        workflow.add_node("safety_check", self.safety_check)
        
        # Set entry point
        workflow.set_entry_point("entry_point")
        
        # Add conditional routing from entry point
        workflow.add_conditional_edges(
            "entry_point",
            self._route_based_on_status,
            {
                "landing": "landing_node",
                "takeoff": "takeoff_node",
                "end": END
            }
        )
        
        # Connect operation nodes to safety check
        workflow.add_edge("landing_node", "safety_check")
        workflow.add_edge("takeoff_node", "safety_check")
        
        # Add conditional routing after safety check
        workflow.add_conditional_edges(
            "safety_check",
            self._route_after_safety_check,
            {
                "retry_landing": "landing_node",
                "retry_takeoff": "takeoff_node",
                "end": END
            }
        )
        
        print("[INIT] Workflow built successfully")
        return workflow.compile()
    
    # ========================================================================
    # API Helper Methods
    # ========================================================================
    
    def _get_runway_status(self) -> list:
        """
        Get current status of all runways.
        
        Returns:
            List of runway detail dictionaries
        """
        print("[API] Fetching runway status...")
        return [runway.get_runway_details() for runway in self.airport.runways]
    
    def _get_other_flights(self) -> list:
        """
        Fetch information about all other flights in the airspace.
        
        Returns:
            List of flight dictionaries excluding the current flight
        """
        print("[API] Fetching other flights...")
        try:
            response = requests.get(f"{API_BASE_URL}/flights/")
            flights = response.json()
            other_flights = [f for f in flights if f["callsign"] != self.flight_id]
            print(f"[API] Found {len(other_flights)} other flights")
            return other_flights
        except Exception as e:
            print(f"[API] ERROR fetching flights: {e}")
            return []
    
    def _get_landing_rules(self) -> dict:
        """
        Fetch landing rules from the simulator API.
        
        Returns:
            Dictionary containing landing rules
        """
        print("[API] Fetching landing rules...")
        try:
            response = requests.get(f"{API_BASE_URL}/landing-rules")
            return response.json()
        except Exception as e:
            print(f"[API] ERROR fetching landing rules: {e}")
            return {}

    def _get_waypoints(self) -> dict:
        """
        Fetch waypoint information from the simulator API.
        
        Returns:
            Dictionary containing waypoint data
        """
        print("[API] Fetching waypoints...")
        try:
            response = requests.get(f"{API_BASE_URL}/waypoints")
            return response.json()
        except Exception as e:
            print(f"[API] ERROR fetching waypoints: {e}")
            return {}
    
    # ========================================================================
    # Workflow Nodes
    # ========================================================================
    
    def entry_point(self, state: ATCState) -> ATCState:
        """
        Entry node - initializes the workflow state.
        
        Loads previous conversation history and sets up initial state
        based on flight status.
        
        Args:
            state: Current workflow state
            
        Returns:
            Updated state with initial context
        """
        flight_info = state["flight_info"]
        status = flight_info.get("status", "")
        callsign = flight_info.get("callsign", state["flight_id"])
        
        print(f"[ENTRY] Processing flight {callsign} with status: {status}")
        
        # Add initial system message
        state["messages"].append({
            "role": "system",
            "content": f"Flight {callsign} status: {status}"
        })
        
        # Load previous conversation history from database
        print("[ENTRY] Loading previous conversation history...")
        state["prev_convo"] = ATCDatabase().get_records(state['flight_id'], 30)
        print(f"[ENTRY] Loaded {len(state['prev_convo'])} previous records")
        
        return state
    
    def _route_based_on_status(self, state: ATCState) -> Literal["landing", "takeoff", "end"]:
        """
        Route to appropriate handler based on flight status.
        
        Args:
            state: Current workflow state
            
        Returns:
            Route identifier: "landing", "takeoff", or "end"
        """
        status = state["flight_info"].get("status", "")
        
        # Landing statuses
        if status in ["approaching", "on_final", "landing"]:
            print(f"[ROUTING] Status '{status}' -> landing_node")
            return "landing"
        
        # Takeoff statuses
        if status in ["ready_for_takeoff", "taking_off"]:
            print(f"[ROUTING] Status '{status}' -> takeoff_node")
            return "takeoff"
        
        # Unknown status - end workflow
        print(f"[ROUTING] Status '{status}' not handled -> end")
        return "end"
    
    def landing_node(self, state: ATCState) -> ATCState:
        """
        Handle landing operations using LLM.
        
        Constructs a detailed prompt with flight info, weather, traffic,
        and landing rules, then invokes the LLM to generate appropriate
        ATC commands.
        
        Args:
            state: Current workflow state
            
        Returns:
            Updated state with landing command
        """
        flight_info = state["flight_info"]
        callsign = flight_info.get("callsign", self.flight_id)
        
        print(f"[LANDING] Processing landing for {callsign}")
        
        # Gather contextual information
        print("[LANDING] Gathering contextual data...")
        weather_info = WeatherInfo().get_noaa_weather("KSEA")
        other_flights = self._get_other_flights()
        runway_details = self._get_runway_status()
        landing_rules = self._get_landing_rules()
        waypoints = self._get_waypoints()
        
        print(f"[LANDING] Context gathered - {len(other_flights)} other flights in airspace")

        # Construct the landing prompt for LLM
        landing_prompt = f"""You are an experienced Air Traffic Controller at a busy airport, responsible for the safe and efficient landing of flight {callsign}. Your primary duties are to sequence aircraft, maintain safe separation, and guide them through the standard landing pattern to Runway 34.

        ## ROLE AND RESPONSIBILITIES
        As an Air Traffic Controller, you must:
        - Maintain safe separation between all aircraft (minimum 3 nautical miles horizontal OR 1000 feet vertical)
        - Sequence aircraft efficiently for landing on Runway 34
        - Issue clear, precise vectoring instructions
        - Monitor weather conditions and adjust procedures accordingly
        - Ensure compliance with all landing rules and regulations
        - Communicate using standard aviation phraseology

        ## CURRENT FLIGHT INFORMATION
        Flight Details:
        {json.dumps(state['flight_info'], indent=2)}

        Recent Communication History:
        {json.dumps(state['messages'], indent=2)}

        Previous 30 Minutes Context:
        {json.dumps(state['prev_convo'], indent=2)}

        ## AIRSPACE STRUCTURE AND WAYPOINTS

        ### Entry Points (Altitude: 6000 feet)
        - NORTH
        - EAST  
        - SOUTH
        - WEST

        Standard Landing Pattern Waypoints:
        {waypoints}

        ## STANDARD LANDING ROUTES

        You must route aircraft through ONE of these approved patterns:

        1. **NORTH → DOWNWIND → BASE → FINAL → RUNWAY 34**
        2. **EAST → DOWNWIND → BASE → FINAL → RUNWAY 34**
        3. **SHORT_EAST → DOWNWIND → BASE → FINAL → RUNWAY 34**
        4. **SOUTH → SHORT_EAST → DOWNWIND → BASE → FINAL → RUNWAY 34**
        5. **WEST → DOWNWIND → BASE → FINAL → RUNWAY 34**

        **Important**: If runway separation requires delaying an aircraft, vector it to SHORT_EAST for sequencing before continuing to DOWNWIND.

        ## LANDING RULES AND PROCEDURES
        {landing_rules}

        ## CURRENT WEATHER CONDITIONS
        {weather_info}

        ## TRAFFIC INFORMATION
        Other Aircraft in the Pattern:
        {other_flights}

        ## RUNWAY INFORMATION
        {runway_details}

        **Critical Note**: There is only ONE runway. Aircraft can only land from ONE direction (Runway 34, landing from south to north).

        ## TIMING ASSUMPTIONS FOR SEPARATION

        - **Aircraft cleared for landing on FINAL**: Approximately 9 minutes to touchdown and runway exit
        - **Aircraft vacating runway after landing**: Approximately 1 minute to clear the active runway
        - **Departing aircraft**: Will proceed directly to NORTH waypoint after takeoff

        ## DECISION-MAKING PROCESS (Chain of Thought)

        For each command, work through these steps systematically:

        ### Step 1: ASSESS CURRENT SITUATION
        - What is the aircraft's current position, altitude, and speed?
        - Where is the aircraft in relation to the standard pattern?
        - What was the last instruction given to this aircraft?

        ### Step 2: ANALYZE TRAFFIC CONFLICTS
        - Are there other aircraft on FINAL approach or landing?
        - If yes, how much time until the runway is clear?
        - Is there adequate separation (3nm horizontal OR 1000ft vertical)?
        - Are there departing aircraft that might conflict?

        ### Step 3: DETERMINE APPROPRIATE ROUTING
        - Which entry point is the aircraft closest to based on current position and heading?
        - Which standard route should this aircraft follow?
        - Is the aircraft already established on a route, or does it need initial vectoring?

        ### Step 4: EVALUATE SEQUENCING NEEDS
        - Can the aircraft proceed directly to the next pattern waypoint?
        - Does traffic require holding or extended routing (vector to SHORT_EAST)?
        - What altitude and speed are appropriate for the next waypoint?

        ### Step 5: CHECK LANDING CLEARANCE CRITERIA
        Can you clear the aircraft to land? Only if ALL conditions are met:
        - Aircraft is established on FINAL approach
        - Aircraft is at or descending to 1000 feet
        - Aircraft speed is approximately 100 knots
        - Runway is clear (no aircraft landing or departing)
        - No traffic conflicts exist
        - Weather is within landing minimums

        ### Step 6: FORMULATE COMMAND
        Based on your analysis, issue ONE of these commands:

        ## OUTPUT FORMATS

        Your response must be ONLY a valid JSON object in ONE of these three formats:

        ### Format 1: Vector to Waypoint
        Use when directing aircraft to a named waypoint in the pattern:
        ```json
        {{"waypoint": "WAYPOINT_NAME", "altitude": TARGET_ALT, "speed": TARGET_SPEED}}
        ```
        Example: {{"waypoint": "DOWNWIND", "altitude": 2000, "speed": 150}}

        ### Format 2: Vector by Heading
        Use when precise heading control is needed (non-standard vectors, conflict resolution):
        ```json
        {{"heading": HEADING_DEGREES, "altitude": TARGET_ALT, "speed": TARGET_SPEED}}
        ```
        Example: {{"heading": 270, "altitude": 3000, "speed": 180}}

        ### Format 3: Landing Clearance
        Use ONLY when all landing criteria are satisfied:
        ```json
        {{"clear_to_land": true}}
        ```

        ## CRITICAL INSTRUCTIONS

        1. **Think step-by-step** through the decision process outlined above
        2. **Prioritize safety** - when in doubt, maintain extra separation
        3. **Follow standard routes** - only deviate for traffic conflicts or safety
        4. **Issue one command at a time** - aircraft will acknowledge and comply
        5. **Monitor progress** - each command moves the aircraft toward landing
        6. **Output ONLY JSON** - no explanations, no additional text, just the JSON object

        ## YOUR TASK

        Analyze the current situation for flight {callsign} using the chain-of-thought process above, then provide the next appropriate ATC command in the specified JSON format.

        Response (JSON only):
        """

        # Invoke LLM and process response
        state["messages"].append({"role": "user", "content": landing_prompt})
        
        try:
            print("[LANDING] Invoking LLM for landing decision...")
            response = self.llm.invoke(landing_prompt)
            llm_output = response if isinstance(response, str) else str(response)
            
            # Parse JSON from LLM output
            command = self._parse_json_from_response(llm_output)
            
            state["command"] = command
            state["messages"].append({"role": "assistant", "content": llm_output})
            
            print(f"[LANDING] Generated command: {command}")
            
        except Exception as e:
            print(f"[LANDING] ERROR: {e}")
            state["command"] = {"error": str(e)}
        
        return state
    
    def takeoff_node(self, state: ATCState) -> ATCState:
        """
        Handle takeoff operations using LLM.
        
        Constructs a prompt focusing on runway clearance verification
        and invokes the LLM to make takeoff clearance decisions.
        
        Args:
            state: Current workflow state
            
        Returns:
            Updated state with takeoff command
        """
        flight_info = state["flight_info"]
        callsign = flight_info.get("callsign", self.flight_id)
        
        print(f"[TAKEOFF] Processing takeoff for {callsign}")
        
        # Gather contextual information
        print("[TAKEOFF] Gathering contextual data...")
        weather_info = WeatherInfo().get_noaa_weather("KSEA")
        other_flights = self._get_other_flights()
        runway_details = self._get_runway_status()
        waypoints = self._get_waypoints()
        
        print(f"[TAKEOFF] Context gathered - {len(other_flights)} other flights in airspace")

        # Construct the takeoff prompt for LLM
        takeoff_prompt = f"""You are an experienced Air Traffic Controller at a busy airport, responsible for the safe departure clearance of flight {callsign}. Your primary duty is to ensure the runway is clear and safe before authorizing takeoff.

        ## ROLE AND RESPONSIBILITIES
        As an Air Traffic Controller managing departures, you must:
        - Verify runway availability and safety before issuing takeoff clearance
        - Monitor all aircraft in critical phases of flight (landing and takeoff)
        - Maintain runway separation between departing and arriving aircraft
        - Ensure no conflicts exist with aircraft on final approach or on the runway
        - Issue clear, unambiguous clearance decisions

        ## CURRENT FLIGHT INFORMATION
        Flight Requesting Takeoff:
        {json.dumps(state['flight_info'], indent=2)}

        Recent Communication History:
        {json.dumps(state['messages'], indent=2)}

        Previous 30 Minutes Context:
        {json.dumps(state['prev_convo'], indent=2)}

        ## DEPARTURE PROCEDURES

        ### Standard Departure Route
        **ALL departing aircraft follow this route:**
        - Takeoff from Runway 34
        - Climb straight out
        - Proceed directly to NORTH waypoint at (0, 25)
        - Maintain departure altitude as assigned (typically 6000 feet)

        ### NORTH Waypoint Details
        {waypoints.get('NORTH', 'N/A')}

        ## RUNWAY INFORMATION
        {runway_details}

        **Critical**: There is only ONE runway. Aircraft landing and taking off share the same runway surface.

        ## TRAFFIC INFORMATION
        Current Aircraft in the Pattern:
        {other_flights}

        ## WEATHER CONDITIONS
        {weather_info}

        ## CLEARANCE DECISION LOGIC

        You must analyze the traffic and determine if it is safe to clear this aircraft for takeoff.

        **Step 1: Check for Runway Conflicts**
        Scan all aircraft in the pattern. The runway is NOT CLEAR if ANY aircraft meets these criteria:

        1. **Aircraft occupying runway**: 
        - `passed_waypoints` list ends with "RUNWAY"
        
        2. **Aircraft currently taking off**:
        - `status` == "taking_off"
        
        3. **Aircraft currently landing**:
        - `status` == "landing"
        
        4. **Aircraft on short final (imminent landing)**:
        - `passed_waypoints` list ends with "FINAL" AND
        - `target_waypoint` == "RUNWAY"

        **Step 2: Make Decision**
        - If ANY aircraft meets the above criteria → DENY takeoff clearance
        - If NO aircraft meets the above criteria → GRANT takeoff clearance

        ## OUTPUT FORMAT

        Provide ONLY a JSON object with no explanation:

        **Clearance Granted:**
        ```json
        {{"cleared_for_takeoff": true}}
        ```

        **Clearance Denied:**
        ```json
        {{"cleared_for_takeoff": false}}
        ```
        """

        # Invoke LLM and process response
        state["messages"].append({"role": "user", "content": takeoff_prompt})
        
        try:
            print("[TAKEOFF] Invoking LLM for takeoff decision...")
            response = self.llm.invoke(takeoff_prompt)
            llm_output = response if isinstance(response, str) else str(response)
            
            # Parse JSON from LLM output
            command = self._parse_json_from_response(llm_output)
            
            state["command"] = command
            state["messages"].append({"role": "assistant", "content": llm_output})
            
            print(f"[TAKEOFF] Generated command: {command}")
            
        except Exception as e:
            print(f"[TAKEOFF] ERROR: {e}")
            state["command"] = {"error": str(e)}
        
        return state
    
    def _parse_json_from_response(self, llm_output: str) -> dict:
        """
        Extract and parse JSON from LLM response.
        
        Args:
            llm_output: Raw text output from the LLM
            
        Returns:
            Parsed JSON as dictionary, or empty dict if parsing fails
        """
        # Try to find JSON in code blocks first
        match = re.search(r"```json(.*?)```", llm_output, re.DOTALL)
        if match:
            json_text = match.group(1).strip()
            try:
                command = json.loads(json_text)
                print(f"[PARSE] Successfully parsed JSON from code block")
                return command
            except json.JSONDecodeError as e:
                print(f"[PARSE] Failed to parse JSON from code block: {e}")
        
        # Try to parse the entire response as JSON
        try:
            command = json.loads(llm_output.strip())
            print(f"[PARSE] Successfully parsed JSON from raw response")
            return command
        except json.JSONDecodeError:
            pass
        
        print("[PARSE] WARNING: No valid JSON found in response")
        return {}
    
    def safety_check(self, state: ATCState) -> ATCState:
        """
        Perform safety validation on the generated command.
        
        Checks for:
        - Takeoff conflicts with landing/departing aircraft
        - Landing route conflicts with other aircraft
        - Collision risks using predictive detection
        
        Args:
            state: Current workflow state
            
        Returns:
            Updated state with validation result
        """
        command = state["command"]
        flight_info = state["flight_info"]
        status = flight_info.get("status", "")
        
        print(f"[SAFETY] Validating command: {command}")
        print(f"[SAFETY] Flight status: {status}")
        
        # Get last checkpoint from passed waypoints
        passed_waypoints = self.flight_info.get("passed_waypoints", [])
        last_checkpoint = passed_waypoints[-1] if passed_waypoints else ""
        print(f"[SAFETY] Last checkpoint: {last_checkpoint or 'None'}")
        
        # Fetch other flights for conflict detection
        flights = self._get_other_flights()
        
        # ----- TAKEOFF SAFETY CHECK -----
        if status in ["ready_for_takeoff", "taking_off"]:
            print("[SAFETY] Performing takeoff safety checks...")
            
            for flight in flights:
                flight_passed = flight.get("passed_waypoints", [])
                flight_last_checkpoint = flight_passed[-1] if flight_passed else ""
                flight_status = flight.get("status", "")
                
                # Check if runway is occupied or aircraft on final
                is_runway_conflict = (
                    flight_last_checkpoint in ["FINAL", "RUNWAY"] or
                    flight_status == "taking_off"
                )
                
                if is_runway_conflict and command.get("cleared_for_takeoff"):
                    print(f"[SAFETY] FAILED: Runway conflict with {flight.get('callsign', 'unknown')}")
                    state['messages'].append({
                        "role": "user",
                        "content": f"Failed safety check for takeoff - runway conflict with: {flight}"
                    })
                    state["result"] = {}
                    return state
            
            # Takeoff safety check passed
            print("[SAFETY] Takeoff safety check PASSED")
            state["result"] = command
            return state
        
        # ----- LANDING SAFETY CHECK -----
        # Define next checkpoint mapping for landing pattern
        next_checkpoint_map = {
            "DOWNWIND": "BASE",
            "BASE": "FINAL",
            "FINAL": "RUNWAY",
            "RUNWAY": "RUNWAY"
        }
        
        # Check if we're in the landing pattern
        if last_checkpoint in next_checkpoint_map:
            target_waypoint = command.get("waypoint", "")
            expected_next = next_checkpoint_map.get(last_checkpoint, "")
            
            # If command is directing to the next sequential waypoint, check for conflicts
            if target_waypoint and target_waypoint == expected_next:
                print(f"[SAFETY] Checking landing pattern conflict: {last_checkpoint} -> {target_waypoint}")
                
                for flight in flights:
                    flight_passed = flight.get("passed_waypoints", [])
                    flight_last = flight_passed[-1] if flight_passed else ""
                    flight_target = flight.get("target_waypoint", "")
                    
                    # Check if another flight is on same route segment
                    if flight_last == last_checkpoint and flight_target == target_waypoint:
                        print(f"[SAFETY] FAILED: Route conflict with {flight.get('callsign', 'unknown')}")
                        state['messages'].append({
                            "role": "user",
                            "content": f"Failed safety check - route conflict with: {flight}"
                        })
                        state["result"] = {}
                        return state
        
        # For aircraft not in landing pattern, use collision detection
        elif last_checkpoint not in ["DOWNWIND", "BASE", "FINAL", "RUNWAY"]:
            print("[SAFETY] Performing collision detection for en-route aircraft...")
            
            from collision_detection import predict_conflict
            
            for flight in flights:
                if predict_conflict(flight_info, flight):
                    print(f"[SAFETY] FAILED: Collision risk with {flight.get('callsign', 'unknown')}")
                    state['messages'].append({
                        "role": "user",
                        "content": f"Failed safety check - collision risk (<1000ft separation) with: {flight}"
                    })
                    state["result"] = {}
                    return state
        
        # All safety checks passed
        print("[SAFETY] All safety checks PASSED")
        state["result"] = command
        
        # Handle runway assignment for landing clearance
        if command.get('clear_to_land'):
            print("[SAFETY] Assigning runway for landing clearance...")
            try:
                current_time = time.time()
                self.airport.runway.assign_flight(
                    self.flight_obj,
                    current_time,
                    current_time + 5  # 5 minute window
                )
                print("[SAFETY] Runway assigned successfully")
            except Exception as e:
                print(f"[SAFETY] WARNING: Failed to assign runway: {e}")
        
        return state
    
    def _route_after_safety_check(self, state: ATCState) -> Literal["retry_landing", "retry_takeoff", "end"]:
        """
        Determine next action after safety check.
        
        Args:
            state: Current workflow state
            
        Returns:
            Route identifier for retry or end
        """
        result = state.get("result", {})
        retry_count = state.get("retry_count", 0)
        max_retries = 3
        
        # If safety check passed, end workflow
        if result:
            print("[ROUTING] Safety check passed -> end")
            return "end"
        
        # Check retry limit
        if retry_count >= max_retries:
            print(f"[ROUTING] Max retries ({max_retries}) reached -> end")
            return "end"
        
        # Increment retry count
        state["retry_count"] = retry_count + 1
        
        # Retry based on flight status
        status = state["flight_info"].get("status", "")
        
        if status in ["approaching", "on_final", "landing"]:
            print(f"[ROUTING] Retrying landing (attempt {retry_count + 1}/{max_retries})")
            return "retry_landing"
        
        if status in ["ready_for_takeoff", "taking_off"]:
            print(f"[ROUTING] Retrying takeoff (attempt {retry_count + 1}/{max_retries})")
            return "retry_takeoff"
        
        print("[ROUTING] Unknown status -> end")
        return "end"
    
    # ========================================================================
    # Public Methods
    # ========================================================================
    
    def run(self) -> dict:
        """
        Execute the ATC workflow for the flight.
        
        Returns:
            Dictionary containing the final workflow result
        """
        print(f"\n{'='*60}")
        print(f"  STARTING ATC AGENT FOR FLIGHT: {self.flight_id}")
        print(f"{'='*60}\n")
        
        # Invoke the workflow
        result = self.workflow.invoke(self.state)
        
        print(f"\n{'='*60}")
        print(f"  ATC AGENT COMPLETED FOR FLIGHT: {self.flight_id}")
        print(f"  Final Result: {result.get('result', {})}")
        print(f"{'='*60}\n")
        
        return result


# ============================================================================
# Main Entry Point
# ============================================================================

def main(flight_info: dict, airport: Airport) -> None:
    """
    Main entry point for running the ATC agent.
    
    Creates an ATCAgent instance, runs the workflow, and sends
    the resulting command to the simulator API.
    
    Args:
        flight_info: Dictionary containing flight information
        airport: Airport object with runway configuration
    """
    flight_id = flight_info['callsign']
    print(f"[MAIN] Starting ATC processing for flight {flight_id}")
    
    # Create and run agent
    agent = ATCAgent(airport, flight_id, flight_info)
    result = agent.run()
    
    # Extract command from result
    command = result.get('result', {})
    
    # Send command to simulator if we have one
    if command:
        print(f"[MAIN] Sending command to simulator: {command}")
        
        headers = {
            "Content-Type": "application/json"
        }
        url = f"{API_BASE_URL}/flights/{flight_id}/command"
        
        try:
            response = requests.post(url, json=command, headers=headers)
            print(f"[MAIN] Simulator response: {response.status_code}")
        except Exception as e:
            print(f"[MAIN] ERROR sending command: {e}")
    else:
        print(f"[MAIN] No command generated for flight {flight_id}")
