"""
ATC Agent Module
================
This module implements an AI-powered Air Traffic Controller agent using LangGraph
for workflow management and Google's Gemini LLM for decision-making.

The agent handles:
- Landing operations: Guiding aircraft through the landing pattern
- Takeoff operations: Clearing aircraft for departure
- Safety checks: Validating commands against traffic conflicts
"""

import os
import json
import re
import time
from typing import TypedDict, Literal

import requests
import google.generativeai as genai
from langgraph.graph import StateGraph, END

from utils.weather_data import WeatherInfo
from flight import Airport, Runway, Flight
from database.atc_db import ATCDatabase
from config import GEMINI_API_KEY
# ============================================================================
# Configuration
# ============================================================================

# Configure Google Gemini API key from environment variable

genai.configure(api_key=GEMINI_API_KEY)

# API Base URL for the ATC Simulator
API_BASE_URL = "http://localhost:8000/api"


# ============================================================================
# LLM Wrapper Class
# ============================================================================

class LLM:
    """
    Wrapper class for Google's Gemini Language Model.
    
    Provides a simple interface to invoke the Gemini model with
    configured generation parameters for ATC decision-making.
    Includes automatic retry logic with configurable delays.
    """
    
    # Retry configuration
    MAX_RETRIES = 3
    RETRY_DELAY_SECONDS = 60  # 1 minute between retries
    
    def __init__(self):
        """Initialize the LLM wrapper."""
        self.model_name = 'gemini-2.5-flash'
        print(f"[LLM] Initialized with model: {self.model_name}")
        print(f"[LLM] Retry config: max_retries={self.MAX_RETRIES}, delay={self.RETRY_DELAY_SECONDS}s")

    def invoke(self, prompt: str) -> str:
        """
        Send a prompt to the Gemini model and get a response.
        
        Implements retry logic with 1-minute delay between attempts
        in case of API failures or rate limiting.
        
        Args:
            prompt: The text prompt to send to the model
            
        Returns:
            The model's response text, or None if all retries failed
        """
        last_error = None
        
        for attempt in range(1, self.MAX_RETRIES + 1):
            try:
                print(f"[LLM] Invoking Gemini model (attempt {attempt}/{self.MAX_RETRIES})...")
                model = genai.GenerativeModel(self.model_name)
                
                response = model.generate_content(
                    prompt,
                    generation_config=genai.types.GenerationConfig(
                        temperature=0.1,  # Low temperature for consistent, deterministic outputs
                        top_p=0.95,
                    )
                )
                
                # Check if we got a valid response
                if response and response.text:
                    response_preview = response.text[:200] if len(response.text) > 200 else response.text
                    print(f"[LLM] Response received: {response_preview}...")
                    return response.text
                else:
                    print(f"[LLM] WARNING: Empty response received on attempt {attempt}")
                    last_error = "Empty response from model"
                
            except Exception as e:
                last_error = str(e)
                print(f"[LLM] ERROR on attempt {attempt}: {e}")
            
            # If this wasn't the last attempt, wait before retrying
            if attempt < self.MAX_RETRIES:
                print(f"[LLM] Waiting {self.RETRY_DELAY_SECONDS} seconds before retry...")
                time.sleep(self.RETRY_DELAY_SECONDS)
        
        # All retries exhausted
        print(f"[LLM] FAILED: All {self.MAX_RETRIES} attempts exhausted. Last error: {last_error}")
        return None

# ============================================================================
# State Definition
# ============================================================================

class ATCState(TypedDict):
    """
    TypedDict defining the state structure for the ATC workflow.
    
    Attributes:
        messages: List of conversation messages between system and LLM
        command: The current command generated by the LLM
        result: The result after safety validation
        flight_id: The unique identifier for the flight
        flight_info: Dictionary containing all flight information
        retry_count: Number of retry attempts for failed safety checks
        prev_convo: Previous conversation history from database
    """
    messages: list
    command: dict
    result: dict
    flight_id: str
    flight_info: dict
    retry_count: int
    prev_convo: list


# ============================================================================
# ATC Agent Class
# ============================================================================

class ATCAgent:
    """
    AI-powered Air Traffic Controller Agent.
    
    Uses LangGraph for workflow management and Gemini LLM for intelligent
    decision-making. Handles both landing and takeoff operations with
    built-in safety checks.
    
    Workflow:
        entry_point -> [landing_node | takeoff_node] -> safety_check -> [retry | end]
    """
    
    def __init__(self, airport: Airport, flight_id: str, flight_info: dict):
        """
        Initialize the ATC Agent for a specific flight.
        
        Args:
            airport: The Airport object containing runway information
            flight_id: The callsign/identifier of the flight to manage
            flight_info: Dictionary containing current flight data
        """
        print(f"[INIT] Creating ATCAgent for flight {flight_id}")
        
        # Store references
        self.airport = airport
        self.flight_id = flight_id
        self.flight_info = flight_info
        
        # Initialize LLM
        self.llm = LLM()
        
        # Create Flight object for runway assignment
        self.flight_obj = Flight(
            flight_id,
            flight_info['aircraft_type'],
            flight_info['origin'],
            flight_info['destination']
        )
        
        # Initialize workflow
        print(f"[INIT] Building LangGraph workflow...")
        self.workflow = self._build_workflow()
        
        # Initialize state
        self.state = {
            "messages": [],
            "command": {},
            "result": {},
            "flight_id": flight_id,
            "flight_info": flight_info,
            "retry_count": 0,
            "prev_convo": []
        }
        
        print(f"[INIT] ATCAgent initialized successfully for {flight_id}")
    
    def _build_workflow(self) -> StateGraph:
        """
        Build and compile the LangGraph workflow.
        
        Returns:
            Compiled StateGraph workflow
        """
        workflow = StateGraph(ATCState)
        
        # Add workflow nodes
        workflow.add_node("entry_point", self.entry_point)
        workflow.add_node("landing_node", self.landing_node)
        workflow.add_node("takeoff_node", self.takeoff_node)
        workflow.add_node("safety_check", self.safety_check)
        
        # Set entry point
        workflow.set_entry_point("entry_point")
        
        # Add conditional routing from entry point
        workflow.add_conditional_edges(
            "entry_point",
            self._route_based_on_status,
            {
                "landing": "landing_node",
                "takeoff": "takeoff_node",
                "end": END
            }
        )
        
        # Connect operation nodes to safety check
        workflow.add_edge("landing_node", "safety_check")
        workflow.add_edge("takeoff_node", "safety_check")
        
        # Add conditional routing after safety check
        workflow.add_conditional_edges(
            "safety_check",
            self._route_after_safety_check,
            {
                "retry_landing": "landing_node",
                "retry_takeoff": "takeoff_node",
                "end": END
            }
        )
        
        print("[INIT] Workflow built successfully")
        return workflow.compile()
    
    # ========================================================================
    # API Helper Methods
    # ========================================================================
    
    def _get_runway_status(self) -> list:
        """
        Get current status of all runways.
        
        Returns:
            List of runway detail dictionaries
        """
        print("[API] Fetching runway status...")
        return [runway.get_runway_details() for runway in self.airport.runways]
    
    def _get_other_flights(self) -> list:
        """
        Fetch information about all other flights in the airspace.
        
        Returns:
            List of flight dictionaries excluding the current flight
        """
        print("[API] Fetching other flights...")
        try:
            response = requests.get(f"{API_BASE_URL}/flights/", timeout=5)
            
            # Check if request was successful
            if response.status_code != 200:
                print(f"[API] WARNING: flights endpoint returned status {response.status_code}")
                return []
            
            # Check if response has content
            if not response.text.strip():
                print("[API] WARNING: flights endpoint returned empty response")
                return []
            
            flights = response.json()
            other_flights = [f for f in flights if f["callsign"] != self.flight_id]
            print(f"[API] Found {len(other_flights)} other flights, {other_flights}, {self.flight_id}")
            return other_flights
            
        except requests.exceptions.ConnectionError:
            print("[API] ERROR: Cannot connect to simulator API. Is the server running?")
            return []
        except requests.exceptions.Timeout:
            print("[API] ERROR: Request timed out")
            return []
        except Exception as e:
            print(f"[API] ERROR fetching flights: {e}")
            return []
    
    def _get_landing_rules(self) -> dict:
        """
        Fetch landing rules from the simulator API.
        
        Returns:
            Dictionary containing landing rules, or default rules if unavailable
        """
        print("[API] Fetching landing rules...")
        
        # Default landing rules as fallback
        default_rules = {
            "minimum_separation_nm": 3,
            "minimum_vertical_separation_ft": 1000,
            "final_approach_altitude_ft": 1000,
            "final_approach_speed_kts": 100,
            "runway": "34"
        }
        
        try:
            response = requests.get(f"{API_BASE_URL}/landing-rules", timeout=5)
            
            # Check if request was successful
            if response.status_code != 200:
                print(f"[API] WARNING: landing-rules endpoint returned status {response.status_code}, using defaults")
                return default_rules
            
            # Check if response has content
            if not response.text.strip():
                print("[API] WARNING: landing-rules endpoint returned empty response, using defaults")
                return default_rules
            
            rules = response.json()
            print("[API] Landing rules fetched successfully")
            return rules
            
        except requests.exceptions.ConnectionError:
            print("[API] ERROR: Cannot connect to simulator API, using default landing rules")
            return default_rules
        except requests.exceptions.Timeout:
            print("[API] ERROR: Request timed out, using default landing rules")
            return default_rules
        except Exception as e:
            print(f"[API] ERROR fetching landing rules: {e}, using defaults")
            return default_rules

    def _get_waypoints(self) -> dict:
        """
        Fetch waypoint information from the simulator API.
        
        Returns:
            Dictionary containing waypoint data, or default waypoints if unavailable
        """
        print("[API] Fetching waypoints...")
        
        # Default waypoints as fallback
        default_waypoints = {
            "NORTH": {"x": 0, "y": 25, "altitude": 6000},
            "EAST": {"x": 25, "y": 0, "altitude": 6000},
            "SOUTH": {"x": 0, "y": -25, "altitude": 6000},
            "WEST": {"x": -25, "y": 0, "altitude": 6000},
            "SHORT_EAST": {"x": 15, "y": 0, "altitude": 4000},
            "DOWNWIND": {"x": 5, "y": 5, "altitude": 2000},
            "BASE": {"x": 0, "y": 5, "altitude": 1500},
            "FINAL": {"x": 0, "y": 2, "altitude": 1000},
            "RUNWAY": {"x": 0, "y": 0, "altitude": 0}
        }
        
        try:
            response = requests.get(f"{API_BASE_URL}/waypoints", timeout=5)
            
            # Check if request was successful
            if response.status_code != 200:
                print(f"[API] WARNING: waypoints endpoint returned status {response.status_code}, using defaults")
                return default_waypoints
            
            # Check if response has content
            if not response.text.strip():
                print("[API] WARNING: waypoints endpoint returned empty response, using defaults")
                return default_waypoints
            
            waypoints = response.json()
            print("[API] Waypoints fetched successfully")
            return waypoints
            
        except requests.exceptions.ConnectionError:
            print("[API] ERROR: Cannot connect to simulator API, using default waypoints")
            return default_waypoints
        except requests.exceptions.Timeout:
            print("[API] ERROR: Request timed out, using default waypoints")
            return default_waypoints
        except Exception as e:
            print(f"[API] ERROR fetching waypoints: {e}, using defaults")
            return default_waypoints
    
    # ========================================================================
    # Workflow Nodes
    # ========================================================================
    
    def entry_point(self, state: ATCState) -> ATCState:
        """
        Entry node - initializes the workflow state.
        
        Loads previous conversation history and sets up initial state
        based on flight status.
        
        Args:
            state: Current workflow state
            
        Returns:
            Updated state with initial context
        """
        flight_info = state["flight_info"]
        status = flight_info.get("status", "")
        callsign = flight_info.get("callsign", state["flight_id"])
        
        print(f"[ENTRY] Processing flight {callsign} with status: {status}")
        
        # Add initial system message
        state["messages"].append({
            "role": "system",
            "content": f"Flight {callsign} status: {status}"
        })
        
        # Load previous conversation history from database
        print("[ENTRY] Loading previous conversation history...")
        state["prev_convo"] = ATCDatabase().get_records(state['flight_id'], 30)
        print(f"[ENTRY] Loaded {len(state['prev_convo'])} previous records")
        
        return state
    
    def _route_based_on_status(self, state: ATCState) -> Literal["landing", "takeoff", "end"]:
        """
        Route to appropriate handler based on flight status.
        
        Args:
            state: Current workflow state
            
        Returns:
            Route identifier: "landing", "takeoff", or "end"
        """
        status = state["flight_info"].get("status", "")
        
        # Landing statuses
        if status in ["approaching", "on_final", "landing"]:
            print(f"[ROUTING] Status '{status}' -> landing_node")
            return "landing"
        
        # Takeoff statuses
        if status in ["ready_for_takeoff", "taking_off"]:
            print(f"[ROUTING] Status '{status}' -> takeoff_node")
            return "takeoff"
        
        # Unknown status - end workflow
        print(f"[ROUTING] Status '{status}' not handled -> end")
        return "end"
    
    def landing_node(self, state: ATCState) -> ATCState:
        """
        Handle landing operations using LLM.
        
        Constructs a detailed prompt with flight info, weather, traffic,
        and landing rules, then invokes the LLM to generate appropriate
        ATC commands.
        
        Args:
            state: Current workflow state
            
        Returns:
            Updated state with landing command
        """
        # import pdb; pdb.set_trace()
        flight_info = state["flight_info"]
        callsign = flight_info.get("callsign", self.flight_id)
        
        print(f"[LANDING] Processing landing for {callsign}")
        
        # Gather contextual information
        print("[LANDING] Gathering contextual data...")
        weather_info = WeatherInfo().get_noaa_weather("KSEA")
        other_flights = self._get_other_flights()
        runway_details = self._get_runway_status()
        landing_rules = self._get_landing_rules()
        waypoints = self._get_waypoints()
        
        print(f"[LANDING] Context gathered - {len(other_flights)} other flights in airspace")
        landing_prompt = f"""
            You are an expert Air Traffic Controller for Runway 34. Your objective is to safely sequence flight {callsign} through the traffic pattern.
            You operate as a rigid state machine: Input State -> Logic Check -> Single Output Command.

            ### PART 1: LIVE CONTEXT DATA
            <telemetry>
            {json.dumps(state['flight_info'], indent=2)}
            </telemetry>

            <environment>
            **Waypoints:** {waypoints}
            **Weather:** {weather_info}
            **Runway:** {runway_details}
            **Traffic:** {other_flights}
            </environment>

            <history>
            {json.dumps(state['messages'], indent=2)}
            </history>

            ### PART 2: THE "GOLDEN PATH" LOGIC
            You must move the aircraft through these states in order. NEVER skip a state.

            1. **ENTRY** (North, East, West) -> **DOWNWIND**
            * *CRITICAL EXCEPTION:* If at **SOUTH**, you MUST route to **EAST** first. (Direct South->Downwind cuts through the Base->Final landing path).
            2. **DOWNWIND** -> **BASE**
            3. **BASE** -> **FINAL**
            4. **FINAL** -> **LAND** (Only if cleared)

            **Safety Interrupts:**
            * If separation < 3nm: Hold at current leg or vector to SHORT_EAST.
            * If Go-Around needed: Vector from FINAL -> SHORT_EAST.

            ### PART 3: REFERENCE EXAMPLES (Pattern Matching)
            Use these examples to guide your decision-making.

            **Example 1: Standard Progression**
            *Input:* Plane at DOWNWIND, no traffic conflicts.
            *Reasoning:* Next state is BASE. Path is clear.
            *Output:* {{"waypoint": "BASE", "altitude": 1500, "speed": 140}}

            **Example 2: The "South" Rule (Critical)**
            *Input:* Plane enters at SOUTH.
            *Reasoning:* Cannot go to DOWNWIND directly (unsafe). Must sequence via EAST.
            *Output:* {{"waypoint": "EAST", "altitude": 3000, "speed": 160}}

            **Example 3: Landing Clearance**
            *Input:* Plane on FINAL, alt 1000ft, runway clear.
            *Reasoning:* All criteria met for landing.
            *Output:* {{"clear_to_land": true}}

            ### PART 4: EXECUTION
            Based on the <telemetry> and <environment>, determine the next step in the "Golden Path".
            Return ONLY the JSON object.

            **Format A (Vector):**
            {{"waypoint": "NAME", "altitude": INT, "speed": INT}}

            **Format B (Clearance):**
            {{"clear_to_land": true}}
            """
        # Construct the landing prompt for LLM
        # landing_prompt = f"""You are an experienced Air Traffic Controller at a busy airport, responsible for the safe and efficient landing of flight {callsign}. Your primary duties are to sequence aircraft, maintain safe separation, and guide them through the MANDATORY standard landing pattern to Runway 34.

        # ## ROLE AND RESPONSIBILITIES
        # As an Air Traffic Controller, you must:
        # - Maintain safe separation between all aircraft (minimum 3 nautical miles horizontal OR 1000 feet vertical)
        # - Sequence aircraft efficiently for landing on Runway 34
        # - Issue clear, precise vectoring instructions
        # - Monitor weather conditions and adjust procedures accordingly
        # - Ensure compliance with all landing rules and regulations
        # - Follow the MANDATORY landing sequence: DOWNWIND → BASE → FINAL → LAND

        # ## CURRENT FLIGHT INFORMATION
        # Flight Details:
        # {json.dumps(state['flight_info'], indent=2)}

        # Recent Communication History:
        # {json.dumps(state['messages'], indent=2)}

        # Previous 30 Minutes Context:
        # {json.dumps(state['prev_convo'], indent=2)}

        # ## AIRSPACE STRUCTURE AND WAYPOINTS

        # ### Initial Entry Points (Altitude: 6000 feet)
        # **These are the INITIAL ENTRY POINTS where aircraft first enter the airspace:**
        # - NORTH
        # - EAST  
        # - SOUTH
        # - WEST

        # ### All Available Waypoints in the Pattern:
        # {waypoints}

        # **Note:** There are multiple waypoints available in the airspace. Choose the appropriate waypoint based on:
        # - Aircraft's current position
        # - Aircraft's current heading
        # - Safety and collision avoidance
        # - Maintaining the circular traffic pattern flow

        # ## MANDATORY LANDING SEQUENCE

        # **Every aircraft's ultimate goal is to land via this MANDATORY sequence:**

        # 1. **[Appropriate Waypoint Routing]** → 
        # 2. **DOWNWIND** (Mandatory checkpoint) → 
        # 3. **BASE** (Mandatory checkpoint) → 
        # 4. **FINAL** (Mandatory checkpoint) → 
        # 5. **CLEARED TO LAND** (Runway)

        # **CRITICAL RULES:**
        # - Aircraft can NEVER skip DOWNWIND, BASE, or FINAL
        # - Aircraft can NEVER go backwards in the sequence (e.g., FINAL → BASE → DOWNWIND)
        # - The traffic pattern follows a CIRCULAR FLOW to prevent collisions
        # - Aircraft must be routed to maintain this circular flow and avoid cutting through active approach paths

        # ## STANDARD LANDING ROUTES

        # Examples showing proper circular flow to DOWNWIND, then through the mandatory sequence:

        # 1. **NORTH → DOWNWIND** → BASE → FINAL → RUNWAY
        # 2. **EAST → DOWNWIND** → BASE → FINAL → RUNWAY
        # 3. **SOUTH → EAST → DOWNWIND** → BASE → FINAL → RUNWAY (NEVER route directly to DOWNWIND - this cuts through BASE→FINAL path!)
        # 4. **WEST → DOWNWIND** → BASE → FINAL → RUNWAY
        # 5. **SHORT_EAST → DOWNWIND** → BASE → FINAL → RUNWAY

        # **Special Routing Considerations:**
        # - **From SOUTH**: Route via intermediate waypoints (e.g., SHORT_EAST or EAST) before DOWNWIND to maintain circular flow and avoid cutting through the BASE→FINAL corridor
        # - **SHORT_EAST**: Preferred for aircraft needing to go around from FINAL or for sequencing/delaying before DOWNWIND

        # ## LANDING RULES AND PROCEDURES
        # {landing_rules}

        # ## CURRENT WEATHER CONDITIONS
        # {weather_info}

        # ## TRAFFIC INFORMATION
        # Other Aircraft in the Pattern:
        # {other_flights}

        # ## RUNWAY INFORMATION
        # {runway_details}

        # **Critical Note**: There is only ONE runway. Aircraft can only land from ONE direction (Runway 34, landing from south to north).

        # ## TIMING ASSUMPTIONS FOR SEPARATION

        # - **Aircraft cleared for landing on FINAL**: Approximately 9 minutes to touchdown and runway exit
        # - **Aircraft vacating runway after landing**: Approximately 1 minute to clear the active runway
        # - **Departing aircraft**: Will proceed directly to NORTH waypoint after takeoff

        # ## DECISION-MAKING PROCESS (Chain of Thought)

        # For each command, work through these steps systematically:

        # ### Step 1: IDENTIFY CURRENT POSITION IN SEQUENCE
        # - Where is the aircraft currently? (Entry point, DOWNWIND, BASE, FINAL, or other)
        # - What is the NEXT required waypoint in the mandatory sequence?
        # - Check aircraft's current heading - which direction is it flying?

        # **Position-to-Next-Waypoint Logic:**
        # - **At WAYPoint (NORTH/EAST/SOUTH/WEST/SHORT_EAST/.....)** → Next: **DOWNWIND**
        # - **At DOWNWIND** → Next: **BASE**
        # - **At BASE** → Next: **FINAL**
        # - **At FINAL** → Next: **CLEAR TO LAND** (if criteria met)

        # ### Step 2: SAFETY AND SEPARATION CHECK
        # - Are there traffic conflicts with the next waypoint?
        # - Is there adequate separation (3nm horizontal OR 1000ft vertical)?
        # - Are there aircraft on FINAL or landing that would cause conflicts?
        # - Are there departing aircraft that might conflict?
        # - **CRITICAL**: Will the route to the next waypoint cut through any active approach paths (especially BASE→FINAL corridor)?

        # **If SAFETY CHECK FAILS or COLLISION CONCERNS arise:**

        # The redirection waypoint depends on WHERE the aircraft currently is:

        # - **At FINAL**: Redirect to **SHORT_EAST** (preferred for go-arounds from FINAL)
        # - **At BASE**: Redirect to closest waypoint that maintains circular flow (consider current heading and position)
        # - **At DOWNWIND**: Redirect to closest waypoint that maintains circular flow (consider current heading and position)
        # - **At SOUTH or southern positions**: **NEVER redirect directly to DOWNWIND** - this would cut through the BASE→FINAL corridor. Route via SHORT_EAST, EAST, or other intermediate waypoints first
        # - **From any position**: Choose the closest waypoint that:
        # * Maintains the circular traffic pattern
        # * Avoids cutting through the BASE→FINAL approach path
        # * Considers aircraft's current heading and direction
        # * Provides adequate separation from other traffic

        # **After redirection, aircraft must route back to DOWNWIND to restart the mandatory sequence.**

        # ### Step 3: EVALUATE IF PROCEEDING TO NEXT WAYPOINT IS SAFE
        # **Can the aircraft proceed to the next mandatory waypoint?**

        # - **If YES and no conflicts:**
        # - Issue vector to next waypoint in sequence
        # - Set appropriate altitude and speed
        # - Verify the route maintains circular flow

        # - **If NO due to traffic/separation/collision concerns:**
        # - **Critical consideration**: Where is the aircraft currently located?
        # - Select redirection waypoint based on current position:
        #     * **From FINAL**: Redirect to SHORT_EAST (preferred for go-arounds)
        #     * **From BASE**: Choose closest waypoint considering heading, but maintain circular flow
        #     * **From DOWNWIND**: Choose closest waypoint considering heading, but maintain circular flow  
        #     * **From SOUTH or southern positions**: Route via SHORT_EAST, EAST, or other intermediate waypoints - NEVER direct to DOWNWIND as this cuts through BASE→FINAL path
        # - **ALWAYS verify**: The redirection path does NOT cut through the BASE→FINAL corridor
        # - **ALWAYS verify**: The path maintains the circular traffic pattern
        # - After reaching redirection waypoint, route aircraft back to DOWNWIND to restart mandatory sequence

        # ### Step 4: CHECK LANDING CLEARANCE CRITERIA (Only if at FINAL)
        # **Can you clear the aircraft to land? Only if ALL conditions are met:**
        # - Aircraft is established on FINAL approach
        # - Aircraft is at or descending to 1000 feet
        # - Aircraft speed is approximately 100 knots
        # - Runway is clear (no aircraft landing or departing)
        # - No traffic conflicts exist
        # - Weather is within landing minimums
        # - All previous waypoints (DOWNWIND, BASE) were completed

        # ### Step 5: FORMULATE COMMAND
        # Based on your analysis, issue ONE command:

        # ## OUTPUT FORMATS

        # Your response must be ONLY a valid JSON object in ONE of these two formats:

        # ### Format 1: Vector to Waypoint
        # Use when directing aircraft to the next waypoint in sequence or for re-sequencing:
        # ```json
        # {{"waypoint": "WAYPOINT_NAME", "altitude": TARGET_ALT, "speed": TARGET_SPEED}}
        # ```

        # **Examples:**
        # - At NORTH entry point, no conflicts: `{{"waypoint": "DOWNWIND", "altitude": 2000, "speed": 150}}`
        # - At DOWNWIND, no conflicts: `{{"waypoint": "BASE", "altitude": 1500, "speed": 140}}`
        # - At BASE, no conflicts: `{{"waypoint": "FINAL", "altitude": 1000, "speed": 120}}`
        # - At BASE, traffic conflict, heading east: `{{"waypoint": "EAST", "altitude": 3000, "speed": 160}}`

        # ### Format 2: Landing Clearance
        # Use ONLY when aircraft is at FINAL and all landing criteria are satisfied:
        # ```json
        # {{"clear_to_land": true}}
        # ```

        # ## CRITICAL INSTRUCTIONS

        # 1. **NEVER skip waypoints** - every aircraft must pass through DOWNWIND → BASE → FINAL in order to land
        # 2. **NEVER reverse sequence** - aircraft cannot go FINAL → BASE or BASE → DOWNWIND
        # 3. **ALWAYS maintain circular flow** - choose waypoints that keep the traffic pattern flowing in a circular direction
        # 4. **NEVER route through active approach paths** - especially avoid cutting through the BASE→FINAL corridor
        # 5. **From SOUTH: NEVER direct to DOWNWIND** - always route via intermediate waypoints (SHORT_EAST, EAST) to avoid crossing BASE→FINAL path
        # 6. **From FINAL: Prefer SHORT_EAST for go-arounds** - this is the standard missed approach waypoint
        # 7. **Think step-by-step** through the decision process outlined above
        # 8. **Prioritize safety** - when in doubt, redirect to appropriate waypoint maintaining circular flow
        # 9. **Consider aircraft heading** - when selecting waypoints, factor in the direction aircraft is flying
        # 10. **Issue one command at a time** - aircraft will acknowledge and comply
        # 11. **Output ONLY JSON** - no explanations, no additional text, just the JSON object

        # Provide the next appropriate ATC command in the specified JSON format.

        # Response (JSON only):
        # """

        # Invoke LLM and process response
        state["messages"].append({"role": "user", "content": landing_prompt})
        
        try:
            print("[LANDING] Invoking LLM for landing decision...")
            response = self.llm.invoke(landing_prompt)
            llm_output = response if isinstance(response, str) else str(response)
            
            # Parse JSON from LLM output
            command = self._parse_json_from_response(llm_output)
            
            state["command"] = command
            state["messages"].append({"role": "assistant", "content": llm_output})
            state["result"] = command
            print(f"[LANDING] Generated command: {command}")
            
        except Exception as e:
            print(f"[LANDING] ERROR: {e}")
            state["command"] = {"error": str(e)}
        
        return state
    
    def takeoff_node(self, state: ATCState) -> ATCState:
        """
        Handle takeoff operations using LLM.
        
        Constructs a prompt focusing on runway clearance verification
        and invokes the LLM to make takeoff clearance decisions.
        
        Args:
            state: Current workflow state
            
        Returns:
            Updated state with takeoff command
        """
        flight_info = state["flight_info"]
        callsign = flight_info.get("callsign", self.flight_id)
        
        print(f"[TAKEOFF] Processing takeoff for {callsign}")
        
        # Gather contextual information
        print("[TAKEOFF] Gathering contextual data...")
        weather_info = WeatherInfo().get_noaa_weather("KSEA")
        other_flights = self._get_other_flights()
        runway_details = self._get_runway_status()
        waypoints = self._get_waypoints()
        
        print(f"[TAKEOFF] Context gathered - {len(other_flights)} other flights in airspace")

        # Construct the takeoff prompt for LLM
        takeoff_prompt = f"""You are an experienced Air Traffic Controller at a busy airport, responsible for the safe departure clearance of flight {callsign}. Your primary duty is to ensure the runway is clear and safe before authorizing takeoff.

        ## ROLE AND RESPONSIBILITIES
        As an Air Traffic Controller managing departures, you must:
        - Verify runway availability and safety before issuing takeoff clearance
        - Monitor all aircraft in critical phases of flight (landing and takeoff)
        - Maintain runway separation between departing and arriving aircraft
        - Ensure no conflicts exist with aircraft on final approach or on the runway
        - Issue clear, unambiguous clearance decisions

        ## CURRENT FLIGHT INFORMATION
        Flight Requesting Takeoff:
        {json.dumps(state['flight_info'], indent=2)}

        Recent Communication History:
        {json.dumps(state['messages'], indent=2)}

        Previous 30 Minutes Context:
        {json.dumps(state['prev_convo'], indent=2)}

        ## DEPARTURE PROCEDURES

        ### Standard Departure Route
        **ALL departing aircraft follow this route:**
        - Takeoff from Runway 34
        - Climb straight out
        - Proceed directly to NORTH waypoint at (0, 25)
        - Maintain departure altitude as assigned (typically 6000 feet)

        ### NORTH Waypoint Details
        {waypoints.get('NORTH', 'N/A')}

        ## RUNWAY INFORMATION
        {runway_details}

        **Critical**: There is only ONE runway. Aircraft landing and taking off share the same runway surface.

        ## TRAFFIC INFORMATION
        Current Aircraft in the Pattern:
        {other_flights}

        ## WEATHER CONDITIONS
        {weather_info}

        ## CLEARANCE DECISION LOGIC

        You must analyze the traffic and determine if it is safe to clear this aircraft for takeoff.

        **Step 1: Check for Runway Conflicts**
        Scan all aircraft in the pattern. The runway is NOT CLEAR if ANY aircraft meets these criteria:

        1. **Aircraft occupying runway**: 
        - `passed_waypoints` list ends with "RUNWAY"
        
        2. **Aircraft currently taking off**:
        - `status` == "taking_off"
        
        3. **Aircraft currently landing**:
        - `status` == "landing"
        
        4. **Aircraft on short final (imminent landing)**:
        - `passed_waypoints` list ends with "FINAL" AND
        - `target_waypoint` == "RUNWAY"

        **Step 2: Make Decision**
        - If ANY aircraft meets the above criteria → DENY takeoff clearance
        - If NO aircraft meets the above criteria → GRANT takeoff clearance

        ## OUTPUT FORMAT

        Provide ONLY a JSON object with no explanation:

        **Clearance Granted:**
        ```json
        {{"cleared_for_takeoff": true}}
        ```

        **Clearance Denied:**
        ```json
        {{"cleared_for_takeoff": false}}
        ```
        """

        # Invoke LLM and process response
        state["messages"].append({"role": "user", "content": takeoff_prompt})
        
        try:
            print("[TAKEOFF] Invoking LLM for takeoff decision...")
            response = self.llm.invoke(takeoff_prompt)
            llm_output = response if isinstance(response, str) else str(response)
            
            # Parse JSON from LLM output
            command = self._parse_json_from_response(llm_output)
            
            state["command"] = command
            state["messages"].append({"role": "assistant", "content": llm_output})
            state["result"] = command
            print(f"[TAKEOFF] Generated command: {command}")
            
        except Exception as e:
            print(f"[TAKEOFF] ERROR: {e}")
            state["command"] = {"error": str(e)}
        
        return state
    
    def _parse_json_from_response(self, llm_output: str) -> dict:
        """
        Extract and parse JSON from LLM response.
        
        Args:
            llm_output: Raw text output from the LLM
            
        Returns:
            Parsed JSON as dictionary, or empty dict if parsing fails
        """
        # Try to find JSON in code blocks first
        match = re.search(r"```json(.*?)```", llm_output, re.DOTALL)
        if match:
            json_text = match.group(1).strip()
            try:
                command = json.loads(json_text)
                print(f"[PARSE] Successfully parsed JSON from code block")
                return command
            except json.JSONDecodeError as e:
                print(f"[PARSE] Failed to parse JSON from code block: {e}")
        
        # Try to parse the entire response as JSON
        try:
            command = json.loads(llm_output.strip())
            print(f"[PARSE] Successfully parsed JSON from raw response")
            return command
        except json.JSONDecodeError:
            pass
        
        print("[PARSE] WARNING: No valid JSON found in response")
        return {}
    
    def safety_check(self, state: ATCState) -> ATCState:
        """
        Perform safety validation on the generated command.
        
        Checks for:
        - Takeoff conflicts with landing/departing aircraft
        - Landing pattern conflicts (DOWNWIND->BASE->FINAL->RUNWAY)
        - Clear to land validation (no aircraft on FINAL, RUNWAY, or taking off)
        - Collision risks for en-route aircraft using predictive detection
        
        Args:
            state: Current workflow state
            
        Returns:
            Updated state with validation result
        """
        command = state["command"]
        if command.get("error"):
            return state

        flight_info = state["flight_info"]
        status = flight_info.get("status", "")
        
        print(f"[SAFETY] Validating command: {command}")
        print(f"[SAFETY] Flight status: {status}")
        
        # Get last checkpoint from passed waypoints
        passed_waypoints = flight_info.get("passed_waypoints", [])
        last_checkpoint = passed_waypoints[-1] if passed_waypoints else ""
        print(f"[SAFETY] Last checkpoint: {last_checkpoint or 'None'}")
        
        # Fetch other flights for conflict detection
        flights = self._get_other_flights()
        
        # Landing pattern waypoints
        landing_pattern_waypoints = ["DOWNWIND", "BASE", "FINAL", "RUNWAY"]
        
        # ----- TAKEOFF SAFETY CHECK -----
        if status in ["ready_for_takeoff", "taking_off"]:
            print("[SAFETY] Performing takeoff safety checks...")
            
            if command.get("cleared_for_takeoff"):
                for flight in flights:
                    flight_passed = flight.get("passed_waypoints", [])
                    flight_last_checkpoint = flight_passed[-1] if flight_passed else ""
                    flight_status = flight.get("status", "")
                    
                    # Check if runway is occupied or aircraft on final/taking off
                    is_runway_conflict = (
                        flight_last_checkpoint in ["FINAL", "RUNWAY"] or
                        flight_status in ["taking_off", "landing"]
                    )
                    
                    if is_runway_conflict:
                        print(f"[SAFETY] FAILED: Runway conflict with {flight.get('callsign', 'unknown')}")
                        state['messages'].append({
                            "role": "user",
                            "content": f"Failed safety check for takeoff - runway conflict with: {flight}"
                        })
                        state["result"] = {}
                        return state
            
            # Takeoff safety check passed
            print("[SAFETY] Takeoff safety check PASSED")
            state["result"] = command
            return state
        
        # ----- CLEAR TO LAND SAFETY CHECK -----
        if command.get("clear_to_land"):
            print("[SAFETY] Performing clear-to-land safety checks...")
            
            for flight in flights:
                flight_passed = flight.get("passed_waypoints", [])
                flight_last_checkpoint = flight_passed[-1] if flight_passed else ""
                flight_status = flight.get("status", "")
                
                # Check for conflicts: any flight on FINAL, RUNWAY, or taking off
                is_landing_conflict = (
                    flight_last_checkpoint in ["FINAL", "RUNWAY"] or
                    flight_status in ["taking_off", "landing"]
                )
                
                if is_landing_conflict:
                    print(f"[SAFETY] FAILED: Landing conflict with {flight.get('callsign', 'unknown')} "
                          f"(checkpoint: {flight_last_checkpoint}, status: {flight_status})")
                    state['messages'].append({
                        "role": "user",
                        "content": f"Failed safety check for landing - conflict with: {flight}"
                    })
                    state["result"] = {}
                    return state
            
            # Clear to land safety check passed - assign runway
            print("[SAFETY] Clear-to-land safety check PASSED")
            state["result"] = command
            
            print("[SAFETY] Assigning runway for landing clearance...")
            try:
                current_time = time.time()
                self.airport.runway.assign_flight(
                    self.flight_obj,
                    current_time,
                    current_time + 5  # 5 minute window
                )
                print("[SAFETY] Runway assigned successfully")
            except Exception as e:
                print(f"[SAFETY] WARNING: Failed to assign runway: {e}")
            
            return state
        
        # ----- LANDING PATTERN SAFETY CHECK (DOWNWIND -> BASE -> FINAL -> RUNWAY) -----
        if last_checkpoint in landing_pattern_waypoints:
            target_waypoint = command.get("waypoint", "")
            print(f"[SAFETY] Checking landing pattern: {last_checkpoint} -> {target_waypoint}")
            
            for flight in flights:
                flight_passed = flight.get("passed_waypoints", [])
                flight_last = flight_passed[-1] if flight_passed else ""
                flight_target = flight.get("target_waypoint", "")
                
                # Check if another flight is at the same checkpoint heading to same target
                if flight_last == last_checkpoint and flight_target == target_waypoint:
                    print(f"[SAFETY] FAILED: Route conflict with {flight.get('callsign', 'unknown')} "
                          f"(both at {last_checkpoint} heading to {target_waypoint})")
                    state['messages'].append({
                        "role": "user",
                        "content": f"Failed safety check - route conflict with: {flight}"
                    })
                    state["result"] = {}
                    return state
            
            print("[SAFETY] Landing pattern safety check PASSED")
            state["result"] = command
            return state
        
        # ----- EN-ROUTE COLLISION DETECTION (for random waypoints) -----
        # Only check against non-landing flights
        print("[SAFETY] Performing collision detection for en-route aircraft...")
        
        from collision_detection import predict_conflict
        
        for flight in flights:
            flight_status = flight.get("status", "")
            flight_passed = flight.get("passed_waypoints", [])
            flight_last = flight_passed[-1] if flight_passed else ""
            
            # Skip landing flights (in the landing pattern or actively landing)
            if flight_status in ["landing", "on_final"] or flight_last in landing_pattern_waypoints:
                print(f"[SAFETY] Skipping landing flight {flight.get('callsign', 'unknown')}")
                continue
            
            # Use predict_conflict - check the 'will_conflict' key in the result
            conflict_result = predict_conflict(
                flight_info, 
                flight,
                horizon_min=2.0,  # Check 2 minutes ahead
                horizontal_threshold_nm=5.0,
                vertical_threshold_ft=1000.0
            )
            
            if conflict_result.get("will_conflict"):
                print(f"[SAFETY] FAILED: Collision risk with {flight.get('callsign', 'unknown')}")
                print(f"[SAFETY] Conflict details: time={conflict_result.get('time_of_conflict_min', 'N/A'):.2f}min, "
                      f"h_sep={conflict_result.get('min_horizontal_nm', 'N/A'):.2f}NM, "
                      f"v_sep={conflict_result.get('min_vertical_ft', 'N/A'):.0f}ft")
                state['messages'].append({
                    "role": "user",
                    "content": f"Failed safety check - collision risk (<1000ft separation) with: {flight}"
                })
                state["result"] = {}
                return state
        
        # All safety checks passed
        print("[SAFETY] All safety checks PASSED")
        state["result"] = command
        
        return state
    
    def _route_after_safety_check(self, state: ATCState) -> Literal["retry_landing", "retry_takeoff", "end"]:
        """
        Determine next action after safety check.
        
        Args:
            state: Current workflow state
            
        Returns:
            Route identifier for retry or end
        """
        result = state.get("result", {})
        retry_count = state.get("retry_count", 0)
        max_retries = 3
        
        # If safety check passed, end workflow
        if result:
            print("[ROUTING] Safety check passed -> end")
            return "end"
        
        # Check retry limit
        if retry_count >= max_retries:
            print(f"[ROUTING] Max retries ({max_retries}) reached -> end")
            return "end"
        
        # Increment retry count
        state["retry_count"] = retry_count + 1
        
        # Retry based on flight status
        status = state["flight_info"].get("status", "")
        
        if status in ["approaching", "on_final", "landing"]:
            print(f"[ROUTING] Retrying landing (attempt {retry_count + 1}/{max_retries})")
            return "retry_landing"
        
        if status in ["ready_for_takeoff", "taking_off"]:
            print(f"[ROUTING] Retrying takeoff (attempt {retry_count + 1}/{max_retries})")
            return "retry_takeoff"
        
        print("[ROUTING] Unknown status -> end")
        return "end"
    
    # ========================================================================
    # Public Methods
    # ========================================================================
    
    def run(self) -> dict:
        """
        Execute the ATC workflow for the flight.
        
        Returns:
            Dictionary containing the final workflow result
        """
        print(f"\n{'='*60}")
        print(f"  STARTING ATC AGENT FOR FLIGHT: {self.flight_id}")
        print(f"{'='*60}\n")
        
        # Invoke the workflow
        result = self.workflow.invoke(self.state)
        
        print(f"\n{'='*60}")
        print(f"  ATC AGENT COMPLETED FOR FLIGHT: {self.flight_id}")
        print(f"  Final Result: {result.get('result', {})}")
        print(f"{'='*60}\n")
        
        return result


# ============================================================================
# Main Entry Point
# ============================================================================

def main(flight_info: dict, airport: Airport) -> None:
    """
    Main entry point for running the ATC agent.
    
    Creates an ATCAgent instance, runs the workflow, and sends
    the resulting command to the simulator API.
    
    Args:
        flight_info: Dictionary containing flight information
        airport: Airport object with runway configuration
    """
    flight_id = flight_info['callsign']
    print(f"[MAIN] Starting ATC processing for flight {flight_id}")
    
    # Create and run agent
    agent = ATCAgent(airport, flight_id, flight_info)
    result = agent.run()
    
    # Extract command from result
    command = result.get('result', {})
    
    # Send command to simulator if we have one
    if command:
        print(f"[MAIN] Sending command to simulator: {command}")
        
        headers = {
            "Content-Type": "application/json"
        }
        url = f"{API_BASE_URL}/flights/{flight_id}/command"
        
        try:
            response = requests.post(url, json=command, headers=headers)
            print(f"[MAIN] Simulator response: {response.status_code}")
        except Exception as e:
            print(f"[MAIN] ERROR sending command: {e}")
    else:
        print(f"[MAIN] No command generated for flight {flight_id}")
