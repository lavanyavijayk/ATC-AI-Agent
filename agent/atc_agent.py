"""
ATC Agent Module
================
This module implements an AI-powered Air Traffic Controller agent using LangGraph
for workflow management and Google's Gemini LLM for decision-making.

The agent handles:
- Landing operations: Guiding aircraft through the landing pattern
- Takeoff operations: Clearing aircraft for departure
- Safety checks: Validating commands against traffic conflicts
"""

import os
import json
import re
import time
from typing import TypedDict, Literal

import requests
import google.generativeai as genai
from langgraph.graph import StateGraph, END

from utils.weather_data import WeatherInfo
from airport.airport import Airport
from airport.runway import Runway
from airport.flight import Flight
from database.atc_db import ATCDatabase
from utils.llm import LLM
from prompts.landing_prompt import LANDING_PROMPT
from prompts.take_off_prompt import TAKE_OFF_PROMPT
from config import API_BASE_URL


# ============================================================================
# State Definition
# ============================================================================

class ATCState(TypedDict):
    """
    TypedDict defining the state structure for the ATC workflow.
    
    Attributes:
        messages: List of conversation messages between system and LLM
        command: The current command generated by the LLM
        result: The result after safety validation
        flight_id: The unique identifier for the flight
        flight_info: Dictionary containing all flight information
        retry_count: Number of retry attempts for failed safety checks
        prev_convo: Previous conversation history from database
    """
    messages: list
    command: dict
    result: dict
    flight_id: str
    flight_info: dict
    retry_count: int
    prev_convo: list


# ============================================================================
# ATC Agent Class
# ============================================================================

class ATCAgent:
    """
    AI-powered Air Traffic Controller Agent.
    
    Uses LangGraph for workflow management and Gemini LLM for intelligent
    decision-making. Handles both landing and takeoff operations with
    built-in safety checks.
    
    Workflow:
        entry_point -> [landing_node | takeoff_node] -> safety_check -> [retry | end]
    """
    
    def __init__(self, airport: Airport, flight_id: str, flight_info: dict):
        """
        Initialize the ATC Agent for a specific flight.
        
        Args:
            airport: The Airport object containing runway information
            flight_id: The callsign/identifier of the flight to manage
            flight_info: Dictionary containing current flight data
        """
        print(f"[INIT] Creating ATCAgent for flight {flight_id}")
        
        # Store references
        self.airport = airport
        self.flight_id = flight_id
        self.flight_info = flight_info
        
        # Initialize LLM
        self.llm = LLM()
        
        # Create Flight object for runway assignment
        self.flight_obj = Flight(
            flight_id,
            flight_info['aircraft_type'],
            flight_info['origin'],
            flight_info['destination']
        )
        
        # Initialize workflow
        print(f"[INIT] Building LangGraph workflow...")
        self.workflow = self._build_workflow()
        
        # Initialize state
        self.state = {
            "messages": [],
            "command": {},
            "result": {},
            "flight_id": flight_id,
            "flight_info": flight_info,
            "retry_count": 0,
            "prev_convo": []
        }
        
        print(f"[INIT] ATCAgent initialized successfully for {flight_id}")
    
    def _build_workflow(self) -> StateGraph:
        """
        Build and compile the LangGraph workflow.
        
        Returns:
            Compiled StateGraph workflow
        """
        workflow = StateGraph(ATCState)
        
        # Add workflow nodes
        workflow.add_node("entry_point", self.entry_point)
        workflow.add_node("landing_node", self.landing_node)
        workflow.add_node("takeoff_node", self.takeoff_node)
        workflow.add_node("safety_check", self.safety_check)
        
        # Set entry point
        workflow.set_entry_point("entry_point")
        
        # Add conditional routing from entry point
        workflow.add_conditional_edges(
            "entry_point",
            self._route_based_on_status,
            {
                "landing": "landing_node",
                "takeoff": "takeoff_node",
                "end": END
            }
        )
        
        # Connect operation nodes to safety check
        workflow.add_edge("landing_node", "safety_check")
        workflow.add_edge("takeoff_node", "safety_check")
        
        # Add conditional routing after safety check
        workflow.add_conditional_edges(
            "safety_check",
            self._route_after_safety_check,
            {
                "retry_landing": "landing_node",
                "retry_takeoff": "takeoff_node",
                "end": END
            }
        )
        
        print("[INIT] Workflow built successfully")
        return workflow.compile()
    
    # ========================================================================
    # API Helper Methods
    # ========================================================================
    
    def _get_runway_status(self) -> list:
        """
        Get current status of all runways.
        
        Returns:
            List of runway detail dictionaries
        """
        print("[API] Fetching runway status...")
        return [runway.get_runway_details() for runway in self.airport.runways]
    
    def _get_other_flights(self) -> list:
        """
        Fetch information about all other flights in the airspace.
        
        Returns:
            List of flight dictionaries excluding the current flight
        """
        print("[API] Fetching other flights...")
        try:
            response = requests.get(f"{API_BASE_URL}/flights/", timeout=5)
            
            # Check if request was successful
            if response.status_code != 200:
                print(f"[API] WARNING: flights endpoint returned status {response.status_code}")
                return []
            
            # Check if response has content
            if not response.text.strip():
                print("[API] WARNING: flights endpoint returned empty response")
                return []
            
            flights = response.json()
            other_flights = [f for f in flights if f["callsign"] != self.flight_id]
            print(f"[API] Found {len(other_flights)} other flights, {other_flights}, {self.flight_id}")
            return other_flights
            
        except requests.exceptions.ConnectionError:
            print("[API] ERROR: Cannot connect to simulator API. Is the server running?")
            return []
        except requests.exceptions.Timeout:
            print("[API] ERROR: Request timed out")
            return []
        except Exception as e:
            print(f"[API] ERROR fetching flights: {e}")
            return []
    
    def _get_landing_rules(self) -> dict:
        """
        Fetch landing rules from the simulator API.
        
        Returns:
            Dictionary containing landing rules, or default rules if unavailable
        """
        print("[API] Fetching landing rules...")
        
        # Default landing rules as fallback
        default_rules = {
            "minimum_separation_nm": 3,
            "minimum_vertical_separation_ft": 1000,
            "final_approach_altitude_ft": 1000,
            "final_approach_speed_kts": 100,
            "runway": "34"
        }
        
        try:
            response = requests.get(f"{API_BASE_URL}/landing-rules", timeout=5)
            
            # Check if request was successful
            if response.status_code != 200:
                print(f"[API] WARNING: landing-rules endpoint returned status {response.status_code}, using defaults")
                return default_rules
            
            # Check if response has content
            if not response.text.strip():
                print("[API] WARNING: landing-rules endpoint returned empty response, using defaults")
                return default_rules
            
            rules = response.json()
            print("[API] Landing rules fetched successfully")
            return rules
            
        except requests.exceptions.ConnectionError:
            print("[API] ERROR: Cannot connect to simulator API, using default landing rules")
            return default_rules
        except requests.exceptions.Timeout:
            print("[API] ERROR: Request timed out, using default landing rules")
            return default_rules
        except Exception as e:
            print(f"[API] ERROR fetching landing rules: {e}, using defaults")
            return default_rules

    def _get_waypoints(self) -> dict:
        """
        Fetch waypoint information from the simulator API.
        
        Returns:
            Dictionary containing waypoint data, or default waypoints if unavailable
        """
        print("[API] Fetching waypoints...")
        
        # Default waypoints as fallback
        default_waypoints = {
            "NORTH": {"x": 0, "y": 25, "altitude": 6000},
            "EAST": {"x": 25, "y": 0, "altitude": 6000},
            "SOUTH": {"x": 0, "y": -25, "altitude": 6000},
            "WEST": {"x": -25, "y": 0, "altitude": 6000},
            "SHORT_EAST": {"x": 15, "y": 0, "altitude": 4000},
            "DOWNWIND": {"x": 5, "y": 5, "altitude": 2000},
            "BASE": {"x": 0, "y": 5, "altitude": 1500},
            "FINAL": {"x": 0, "y": 2, "altitude": 1000},
            "RUNWAY": {"x": 0, "y": 0, "altitude": 0}
        }
        
        try:
            response = requests.get(f"{API_BASE_URL}/waypoints", timeout=5)
            
            # Check if request was successful
            if response.status_code != 200:
                print(f"[API] WARNING: waypoints endpoint returned status {response.status_code}, using defaults")
                return default_waypoints
            
            # Check if response has content
            if not response.text.strip():
                print("[API] WARNING: waypoints endpoint returned empty response, using defaults")
                return default_waypoints
            
            waypoints = response.json()
            print("[API] Waypoints fetched successfully")
            return waypoints
            
        except requests.exceptions.ConnectionError:
            print("[API] ERROR: Cannot connect to simulator API, using default waypoints")
            return default_waypoints
        except requests.exceptions.Timeout:
            print("[API] ERROR: Request timed out, using default waypoints")
            return default_waypoints
        except Exception as e:
            print(f"[API] ERROR fetching waypoints: {e}, using defaults")
            return default_waypoints
    
    # ========================================================================
    # Workflow Nodes
    # ========================================================================
    
    def entry_point(self, state: ATCState) -> ATCState:
        """
        Entry node - initializes the workflow state.
        
        Loads previous conversation history and sets up initial state
        based on flight status.
        
        Args:
            state: Current workflow state
            
        Returns:
            Updated state with initial context
        """
        flight_info = state["flight_info"]
        status = flight_info.get("status", "")
        callsign = flight_info.get("callsign", state["flight_id"])
        
        print(f"[ENTRY] Processing flight {callsign} with status: {status}")
        
        # Add initial system message
        state["messages"].append({
            "role": "system",
            "content": f"Flight {callsign} status: {status}"
        })
        
        # Load previous conversation history from database
        print("[ENTRY] Loading previous conversation history...")
        state["prev_convo"] = ATCDatabase().get_records(state['flight_id'], 5)
        print(f"[ENTRY] Loaded {len(state['prev_convo'])} previous records")
        
        return state
    
    def _route_based_on_status(self, state: ATCState) -> Literal["landing", "takeoff", "end"]:
        """
        Route to appropriate handler based on flight status.
        
        Args:
            state: Current workflow state
            
        Returns:
            Route identifier: "landing", "takeoff", or "end"
        """
        status = state["flight_info"].get("status", "")
        
        # Landing statuses
        if status in ["approaching", "on_final", "landing"]:
            print(f"[ROUTING] Status '{status}' -> landing_node")
            return "landing"
        
        # Takeoff statuses
        if status in ["ready_for_takeoff", "taking_off"]:
            print(f"[ROUTING] Status '{status}' -> takeoff_node")
            return "takeoff"
        
        # Unknown status - end workflow
        print(f"[ROUTING] Status '{status}' not handled -> end")
        return "end"
    
    def landing_node(self, state: ATCState) -> ATCState:
        """
        Handle landing operations using LLM.
        
        Constructs a detailed prompt with flight info, weather, traffic,
        and landing rules, then invokes the LLM to generate appropriate
        ATC commands.
        
        Args:
            state: Current workflow state
            
        Returns:
            Updated state with landing command
        """
        # import pdb; pdb.set_trace()
        flight_info = state["flight_info"]
        callsign = flight_info.get("callsign", self.flight_id)
        
        print(f"[LANDING] Processing landing for {callsign}")
        
        # Gather contextual information
        print("[LANDING] Gathering contextual data...")
        weather_info = WeatherInfo().get_noaa_weather("KSEA")
        other_flights = self._get_other_flights()
        runway_details = self._get_runway_status()
        landing_rules = self._get_landing_rules()
        waypoints = self._get_waypoints()
        
        print(f"[LANDING] Context gathered - {len(other_flights)} other flights in airspace")
        landing_prompt = LANDING_PROMPT.format(callsign=callsign,
                                               waypoints=waypoints,
                                               weather_info=weather_info,
                                               runway_details=runway_details,
                                               other_flights=other_flights,
                                               landing_rules=landing_rules,
                                               messages=json.dumps(state['messages'], indent=2),
                                               flight_info=json.dumps(state['flight_info'], indent=2))

        # Invoke LLM and process response
        state["messages"].append({"role": "user", "content": landing_prompt})
        
        try:
            print("[LANDING] Invoking LLM for landing decision...")
            response = self.llm.invoke(landing_prompt)
            llm_output = response if isinstance(response, str) else str(response)
            
            # Parse JSON from LLM output
            command = self._parse_json_from_response(llm_output)
            
            state["command"] = command
            state["messages"].append({"role": "assistant", "content": llm_output})
            state["result"] = command
            print(f"[LANDING] Generated command: {command}")
            
        except Exception as e:
            print(f"[LANDING] ERROR: {e}")
            state["command"] = {"error": str(e)}
        
        return state
    
    def takeoff_node(self, state: ATCState) -> ATCState:
        """
        Handle takeoff operations using LLM.
        
        Constructs a prompt focusing on runway clearance verification
        and invokes the LLM to make takeoff clearance decisions.
        
        Args:
            state: Current workflow state
            
        Returns:
            Updated state with takeoff command
        """
        flight_info = state["flight_info"]
        callsign = flight_info.get("callsign", self.flight_id)
        
        print(f"[TAKEOFF] Processing takeoff for {callsign}")
        
        # Gather contextual information
        print("[TAKEOFF] Gathering contextual data...")
        weather_info = WeatherInfo().get_noaa_weather("KSEA")
        other_flights = self._get_other_flights()
        runway_details = self._get_runway_status()
        waypoints = self._get_waypoints()
        
        print(f"[TAKEOFF] Context gathered - {len(other_flights)} other flights in airspace")

        # Construct the takeoff prompt for LLM
        takeoff_prompt = TAKE_OFF_PROMPT.format(callsign=callsign,
                                               waypoints=waypoints,
                                               weather_info=weather_info,
                                               runway_details=runway_details,
                                               other_flights=other_flights,
                                               messages=json.dumps(state['messages'], indent=2),
                                               flight_info=json.dumps(state['flight_info'], indent=2))

        # Invoke LLM and process response
        state["messages"].append({"role": "user", "content": takeoff_prompt})
        
        try:
            print("[TAKEOFF] Invoking LLM for takeoff decision...")
            response = self.llm.invoke(takeoff_prompt)
            llm_output = response if isinstance(response, str) else str(response)
            
            # Parse JSON from LLM output
            command = self._parse_json_from_response(llm_output)
            
            state["command"] = command
            state["messages"].append({"role": "assistant", "content": llm_output})
            state["result"] = command
            print(f"[TAKEOFF] Generated command: {command}")
            
        except Exception as e:
            print(f"[TAKEOFF] ERROR: {e}")
            state["command"] = {"error": str(e)}
        
        return state
    
    def _parse_json_from_response(self, llm_output: str) -> dict:
        """
        Extract and parse JSON from LLM response.
        
        Args:
            llm_output: Raw text output from the LLM
            
        Returns:
            Parsed JSON as dictionary, or empty dict if parsing fails
        """
        # Try to find JSON in code blocks first
        match = re.search(r"```json(.*?)```", llm_output, re.DOTALL)
        if match:
            json_text = match.group(1).strip()
            try:
                command = json.loads(json_text)
                print(f"[PARSE] Successfully parsed JSON from code block")
                return command
            except json.JSONDecodeError as e:
                print(f"[PARSE] Failed to parse JSON from code block: {e}")
        
        # Try to parse the entire response as JSON
        try:
            command = json.loads(llm_output.strip())
            print(f"[PARSE] Successfully parsed JSON from raw response")
            return command
        except json.JSONDecodeError:
            pass
        
        print("[PARSE] WARNING: No valid JSON found in response")
        return {}
    
    def safety_check(self, state: ATCState) -> ATCState:
        """
        Perform safety validation on the generated command.
        
        Checks for:
        - Takeoff conflicts with landing/departing aircraft
        - Landing pattern conflicts (DOWNWIND->BASE->FINAL->RUNWAY)
        - Clear to land validation (no aircraft on FINAL, RUNWAY, or taking off)
        - Collision risks for en-route aircraft using predictive detection
        
        Args:
            state: Current workflow state
            
        Returns:
            Updated state with validation result
        """
        command = state["command"]
        if command.get("error"):
            return state

        flight_info = state["flight_info"]
        status = flight_info.get("status", "")
        
        print(f"[SAFETY] Validating command: {command}")
        print(f"[SAFETY] Flight status: {status}")
        
        # Get last checkpoint from passed waypoints
        passed_waypoints = flight_info.get("passed_waypoints", [])
        last_checkpoint = passed_waypoints[-1] if passed_waypoints else ""
        print(f"[SAFETY] Last checkpoint: {last_checkpoint or 'None'}")
        
        # Fetch other flights for conflict detection
        flights = self._get_other_flights()
        
        # Landing pattern waypoints
        landing_pattern_waypoints = ["DOWNWIND", "BASE", "FINAL", "RUNWAY"]
        
        # ----- TAKEOFF SAFETY CHECK -----
        if status in ["ready_for_takeoff", "taking_off"]:
            print("[SAFETY] Performing takeoff safety checks...")
            
            if command.get("cleared_for_takeoff"):
                for flight in flights:
                    flight_passed = flight.get("passed_waypoints", [])
                    flight_last_checkpoint = flight_passed[-1] if flight_passed else ""
                    flight_status = flight.get("status", "")
                    
                    # Check if runway is occupied or aircraft on final/taking off
                    is_runway_conflict = (
                        flight_last_checkpoint in ["FINAL", "RUNWAY"] or
                        flight_status in ["taking_off", "landing"]
                    )
                    
                    if is_runway_conflict:
                        print(f"[SAFETY] FAILED: Runway conflict with {flight.get('callsign', 'unknown')}")
                        state['messages'].append({
                            "role": "user",
                            "content": f"Failed safety check for takeoff - runway conflict with: {flight}"
                        })
                        state["result"] = {}
                        return state
            
            # Takeoff safety check passed
            print("[SAFETY] Takeoff safety check PASSED")
            state["result"] = command
            return state
        
        # ----- CLEAR TO LAND SAFETY CHECK -----
        if command.get("clear_to_land"):
            print("[SAFETY] Performing clear-to-land safety checks...")
            
            for flight in flights:
                flight_passed = flight.get("passed_waypoints", [])
                flight_last_checkpoint = flight_passed[-1] if flight_passed else ""
                flight_status = flight.get("status", "")
                
                # Check for conflicts: any flight on FINAL, RUNWAY, or taking off
                is_landing_conflict = (
                    flight_last_checkpoint in ["FINAL", "RUNWAY"] or
                    flight_status in ["taking_off", "landing"]
                )
                
                if is_landing_conflict:
                    print(f"[SAFETY] FAILED: Landing conflict with {flight.get('callsign', 'unknown')} "
                          f"(checkpoint: {flight_last_checkpoint}, status: {flight_status})")
                    state['messages'].append({
                        "role": "user",
                        "content": f"Failed safety check for landing - conflict with: {flight}"
                    })
                    state["result"] = {}
                    return state
            
            # Clear to land safety check passed - assign runway
            print("[SAFETY] Clear-to-land safety check PASSED")
            state["result"] = command
            
            print("[SAFETY] Assigning runway for landing clearance...")
            try:
                current_time = time.time()
                self.airport.runway.assign_flight(
                    self.flight_obj,
                    current_time,
                    current_time + 5  # 5 minute window
                )
                print("[SAFETY] Runway assigned successfully")
            except Exception as e:
                print(f"[SAFETY] WARNING: Failed to assign runway: {e}")
            
            return state
        
        # # ----- LANDING PATTERN SAFETY CHECK (DOWNWIND -> BASE -> FINAL -> RUNWAY) -----
        # if last_checkpoint in landing_pattern_waypoints:
        #     target_waypoint = command.get("waypoint", "")
        #     print(f"[SAFETY] Checking landing pattern: {last_checkpoint} -> {target_waypoint}")
            
        #     for flight in flights:
        #         flight_passed = flight.get("passed_waypoints", [])
        #         flight_last = flight_passed[-1] if flight_passed else ""
        #         flight_target = flight.get("target_waypoint", "")
                
        #         # Check if another flight is at the same checkpoint heading to same target
        #         if flight_last == last_checkpoint and flight_target == target_waypoint:
        #             if not predict_conflict
        #             print(f"[SAFETY] FAILED: Route conflict with {flight.get('callsign', 'unknown')} "
        #                   f"(both at {last_checkpoint} heading to {target_waypoint})")
        #             state['messages'].append({
        #                 "role": "user",
        #                 "content": f"Failed safety check - route conflict with: {flight}"
        #             })
        #             state["result"] = {}
        #             return state
            
        #     print("[SAFETY] Landing pattern safety check PASSED")
        #     state["result"] = command
        #     return state
        
        # ----- EN-ROUTE COLLISION DETECTION (for random waypoints) -----
        # Only check against non-landing flights
        print("[SAFETY] Performing collision detection for en-route aircraft...")
        
        from airport.saftey_checks import predict_conflict
        
        for flight in flights:
            flight_status = flight.get("status", "")
            flight_passed = flight.get("passed_waypoints", [])
            flight_last = flight_passed[-1] if flight_passed else ""
            
            # Skip landing flights (in the landing pattern or actively landing)
            if flight_status in ["landing", "on_final"] or flight_last in landing_pattern_waypoints:
                print(f"[SAFETY] Skipping landing flight {flight.get('callsign', 'unknown')}")
                continue
            
            # Use predict_conflict - check the 'will_conflict' key in the result
            conflict_result = predict_conflict(
                flight_info, 
                flight,
                horizon_min=2.0,  # Check 2 minutes ahead
                horizontal_threshold_nm=5.0,
                vertical_threshold_ft=1000.0
            )
            
            if conflict_result.get("will_conflict"):
                print(f"[SAFETY] FAILED: Collision risk with {flight.get('callsign', 'unknown')}")
                print(f"[SAFETY] Conflict details: time={conflict_result.get('time_of_conflict_min', 'N/A'):.2f}min, "
                      f"h_sep={conflict_result.get('min_horizontal_nm', 'N/A'):.2f}NM, "
                      f"v_sep={conflict_result.get('min_vertical_ft', 'N/A'):.0f}ft")
                state['messages'].append({
                    "role": "user",
                    "content": f"Failed safety check - collision risk (<1000ft separation) with: {flight}"
                })
                state["result"] = {}
                return state
        
        # All safety checks passed
        print("[SAFETY] All safety checks PASSED")
        state["result"] = command
        
        return state
    
    def _route_after_safety_check(self, state: ATCState) -> Literal["retry_landing", "retry_takeoff", "end"]:
        """
        Determine next action after safety check.
        
        Args:
            state: Current workflow state
            
        Returns:
            Route identifier for retry or end
        """
        result = state.get("result", {})
        retry_count = state.get("retry_count", 0)
        max_retries = 3
        
        # If safety check passed, end workflow
        if result:
            print("[ROUTING] Safety check passed -> end")
            return "end"
        
        # Check retry limit
        if retry_count >= max_retries:
            print(f"[ROUTING] Max retries ({max_retries}) reached -> end")
            return "end"
        
        # Increment retry count
        state["retry_count"] = retry_count + 1
        
        # Retry based on flight status
        status = state["flight_info"].get("status", "")
        
        if status in ["approaching", "on_final", "landing"]:
            print(f"[ROUTING] Retrying landing (attempt {retry_count + 1}/{max_retries})")
            return "retry_landing"
        
        if status in ["ready_for_takeoff", "taking_off"]:
            print(f"[ROUTING] Retrying takeoff (attempt {retry_count + 1}/{max_retries})")
            return "retry_takeoff"
        
        print("[ROUTING] Unknown status -> end")
        return "end"
    
    # ========================================================================
    # Public Methods
    # ========================================================================
    
    def run(self) -> dict:
        """
        Execute the ATC workflow for the flight.
        
        Returns:
            Dictionary containing the final workflow result
        """
        print(f"\n{'='*60}")
        print(f"  STARTING ATC AGENT FOR FLIGHT: {self.flight_id}")
        print(f"{'='*60}\n")
        
        # Invoke the workflow
        result = self.workflow.invoke(self.state)
        
        print(f"\n{'='*60}")
        print(f"  ATC AGENT COMPLETED FOR FLIGHT: {self.flight_id}")
        print(f"  Final Result: {result.get('result', {})}")
        print(f"{'='*60}\n")
        
        return result


# ============================================================================
# Main Entry Point
# ============================================================================

def main(flight_info: dict, airport: Airport) -> None:
    """
    Main entry point for running the ATC agent.
    
    Creates an ATCAgent instance, runs the workflow, and sends
    the resulting command to the simulator API.
    
    Args:
        flight_info: Dictionary containing flight information
        airport: Airport object with runway configuration
    """
    flight_id = flight_info['callsign']
    print(f"[MAIN] Starting ATC processing for flight {flight_id}")
    
    # Create and run agent
    agent = ATCAgent(airport, flight_id, flight_info)
    result = agent.run()
    
    # Extract command from result
    command = result.get('result', {})
    
    # Send command to simulator if we have one
    if command:
        print(f"[MAIN] Sending command to simulator: {command}")
        
        headers = {
            "Content-Type": "application/json"
        }
        url = f"{API_BASE_URL}/flights/{flight_id}/command"
        
        try:
            response = requests.post(url, json=command, headers=headers)
            print(f"[MAIN] Simulator response: {response.status_code}")
        except Exception as e:
            print(f"[MAIN] ERROR sending command: {e}")
        db = ATCDatabase()
        db.insert_record(
            command=command,
            result=result,
            flight_id=flight_id,
            flight_info=flight_info,
            retry_count=result.get("retry_count", 0)
        )
    else:
        print(f"[MAIN] No command generated for flight {flight_id}")
